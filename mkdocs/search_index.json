{
    "docs": [
        {
            "location": "/", 
            "text": "ISV Integration Guide\n\n\nAs an Independent Software Vendor (ISV), you are likely to find more and more\nPivotal Cloud Foundry (PCF) users among your customers. Many of these will be\nasking you to integrate your software with PCF to enable use of your software\nwith the applications they are developing on PCF.\n\n\nPivotal is very supportive of these types of integrations and is committed to\nmaking this process as easy as possible. This site provides a \ntechnical\n\noverview on how to integrate your software with PCF. You are welcome to\nstart this process on your own, or \ncontact us\n\nto ask for our support and/or publish your integration in our\n\nmarketplace\n.\n\n\nIf you are new to this site, \nstart here\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#isv-integration-guide", 
            "text": "As an Independent Software Vendor (ISV), you are likely to find more and more\nPivotal Cloud Foundry (PCF) users among your customers. Many of these will be\nasking you to integrate your software with PCF to enable use of your software\nwith the applications they are developing on PCF.  Pivotal is very supportive of these types of integrations and is committed to\nmaking this process as easy as possible. This site provides a  technical \noverview on how to integrate your software with PCF. You are welcome to\nstart this process on your own, or  contact us \nto ask for our support and/or publish your integration in our marketplace .  If you are new to this site,  start here .", 
            "title": "ISV Integration Guide"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting Started\n\n\nAs an Independent Software Vendor (ISV), you are likely to find more and more\nPivotal Cloud Foundry (PCF) users among your customers. Many of these will be\nasking you to integrate your software with PCF to enable use of your software\nwith the applications they are developing on PCF.\n\n\nPivotal is very supportive of these types of integrations and is committed to\nmaking this process as easy as possible. This site provides a \ntechnical\n\noverview on how to integrate your software with PCF. You are welcome to\nstart this process on your own, or \ncontact us\n\nto ask for our support and/or publish your integration in our\n\nmarketplace\n.\n\n\nThere are a lot of things you will have to learn and do to complete an\nintegration with Cloud Foundry. This page attempts to lay out a typical\nprogression of an integration with PCF.\n\n\nStep 0. Understand the concepts\n\n\nThere are \nmany ways\n to integrate products with Cloud Foundry.\nThe right one for each product depends on what the product does, and how\ncustomer applications consume it. To determine the best way to integrate your\nproduct, you'll need a good understanding of\n\nCloud Foundry concepts\n\nlike applications, containers, services, brokers, and buildpacks.\n\n\nStep 1. Design the integration\n\n\nWith sufficient understanding of both your product, and Cloud Foundry concepts,\nyou are in a position to decide what the integration looks like. Integration\npoints might include:\n\n\n\n\nService Brokers\n\n\nManaged Services\n\n\nBuildpacks\n\n\nEmbedded Agents\n\n\nOr any combination of the above\n\n\n\n\nIf you are not intimately familiar with Cloud Foundry, this is one of the\nareas where we can help. We like to do scoping meetings with you, where\nwe pair your understanding of your products, with our understanding of\nCloud Foundry, to map out the best possible integration path.\n\n\nStep 2. Learn how to build\n\n\nDepending on the selected type of integration, you will need to learn\nhow to build on or more of:\n\n\n\n\nService brokers\n\n\nManaged services\n\n\nDynamic services\n\n\nBuildpacks\n\n\nEmbedded agents\n\n\n\n\nSelf-learning is definitely possible. If you are interested in more\norganized learning, Pivotal provides many different classes and labs for\npartners and customers. \nContact us\n\nif your are interested in learning more about this.\n\n\nStep 3. Set up a test environment\n\n\nOnce you move into development, you will need access to a PCF environment.\nPartners who participate in our program have access to a number of shared\nenvironments that are operated and managed by Pivotal. If you are not (yet)\nin our program, need a dedicated environment, or want to be able to work\noffline, you can set up a PCF environment on:\n\n\n\n\nDeveloper desktop/laptop\n\n\nSupported public or private infrastructure (IaaS)\n\n\n\n\nYou will then also need to learn to operate and upgrade PCF by yourself:\n\n\n\n\nOperating a PCF environment\n\n\nUpgrading a PCF environment\n\n\n\n\nStep 4. Validate the design\n\n\nPivotal is a strong believer in lean and agile development and the notion\nof delivering a Minimal Viable Product (MVP) to our customers as quickly\nas possible. So we always look for \nstaged approaches\n to\nthe development of the integration, and only plan the upcoming stage in\ngreat detail.\n\n\nIn most cases, there is a very rapid way to do a proof-of-concept of the\nproposed integration. For instance, if you are building a service, you\ncan often emulate the availability of a brokered, managed, or dynamic\nservice by setting up a \nuser-provided service\n\nfor an existing instance of your service. That will let you validate\nthe integration design before you make a large development investment,\nand it will let real consumers weigh in development priorities.\n\n\nA critical component to this step is the development of consuming\napplications. Those can be real customer applications, or test applications\nthat are deployed to PCF.\n\n\n\n\nDeveloping applications\n\n\nBinding services\n\n\n\n\nStep 5. Develop your tile\n\n\nOnce the design is established and validated, and the first \nstage\n\nhas been defined, you would start actual development of your tile.\n\n\n\n\nDevelop and test the individual components\n\n\nGenerate your tile\n\n\nTest the deploy and delete errands\n\n\nDeploy and test your tile\n\n\n\n\nStep 6. Publish your tile\n\n\n\n\nComplete the documentation\n\n\nWork with Pivotal to publish your tile\n\n\n\n\nStep 7. Maintain your tile\n\n\n\n\nSet up a Concourse Server\n\n\nSet up a Concourse Pipeline\n\n\n\n\nCreate a target PCF pool\n\n\n\n\n\n\nUpgrading tiles", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "As an Independent Software Vendor (ISV), you are likely to find more and more\nPivotal Cloud Foundry (PCF) users among your customers. Many of these will be\nasking you to integrate your software with PCF to enable use of your software\nwith the applications they are developing on PCF.  Pivotal is very supportive of these types of integrations and is committed to\nmaking this process as easy as possible. This site provides a  technical \noverview on how to integrate your software with PCF. You are welcome to\nstart this process on your own, or  contact us \nto ask for our support and/or publish your integration in our marketplace .  There are a lot of things you will have to learn and do to complete an\nintegration with Cloud Foundry. This page attempts to lay out a typical\nprogression of an integration with PCF.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#step-0-understand-the-concepts", 
            "text": "There are  many ways  to integrate products with Cloud Foundry.\nThe right one for each product depends on what the product does, and how\ncustomer applications consume it. To determine the best way to integrate your\nproduct, you'll need a good understanding of Cloud Foundry concepts \nlike applications, containers, services, brokers, and buildpacks.", 
            "title": "Step 0. Understand the concepts"
        }, 
        {
            "location": "/getting-started/#step-1-design-the-integration", 
            "text": "With sufficient understanding of both your product, and Cloud Foundry concepts,\nyou are in a position to decide what the integration looks like. Integration\npoints might include:   Service Brokers  Managed Services  Buildpacks  Embedded Agents  Or any combination of the above   If you are not intimately familiar with Cloud Foundry, this is one of the\nareas where we can help. We like to do scoping meetings with you, where\nwe pair your understanding of your products, with our understanding of\nCloud Foundry, to map out the best possible integration path.", 
            "title": "Step 1. Design the integration"
        }, 
        {
            "location": "/getting-started/#step-2-learn-how-to-build", 
            "text": "Depending on the selected type of integration, you will need to learn\nhow to build on or more of:   Service brokers  Managed services  Dynamic services  Buildpacks  Embedded agents   Self-learning is definitely possible. If you are interested in more\norganized learning, Pivotal provides many different classes and labs for\npartners and customers.  Contact us \nif your are interested in learning more about this.", 
            "title": "Step 2. Learn how to build"
        }, 
        {
            "location": "/getting-started/#step-3-set-up-a-test-environment", 
            "text": "Once you move into development, you will need access to a PCF environment.\nPartners who participate in our program have access to a number of shared\nenvironments that are operated and managed by Pivotal. If you are not (yet)\nin our program, need a dedicated environment, or want to be able to work\noffline, you can set up a PCF environment on:   Developer desktop/laptop  Supported public or private infrastructure (IaaS)   You will then also need to learn to operate and upgrade PCF by yourself:   Operating a PCF environment  Upgrading a PCF environment", 
            "title": "Step 3. Set up a test environment"
        }, 
        {
            "location": "/getting-started/#step-4-validate-the-design", 
            "text": "Pivotal is a strong believer in lean and agile development and the notion\nof delivering a Minimal Viable Product (MVP) to our customers as quickly\nas possible. So we always look for  staged approaches  to\nthe development of the integration, and only plan the upcoming stage in\ngreat detail.  In most cases, there is a very rapid way to do a proof-of-concept of the\nproposed integration. For instance, if you are building a service, you\ncan often emulate the availability of a brokered, managed, or dynamic\nservice by setting up a  user-provided service \nfor an existing instance of your service. That will let you validate\nthe integration design before you make a large development investment,\nand it will let real consumers weigh in development priorities.  A critical component to this step is the development of consuming\napplications. Those can be real customer applications, or test applications\nthat are deployed to PCF.   Developing applications  Binding services", 
            "title": "Step 4. Validate the design"
        }, 
        {
            "location": "/getting-started/#step-5-develop-your-tile", 
            "text": "Once the design is established and validated, and the first  stage \nhas been defined, you would start actual development of your tile.   Develop and test the individual components  Generate your tile  Test the deploy and delete errands  Deploy and test your tile", 
            "title": "Step 5. Develop your tile"
        }, 
        {
            "location": "/getting-started/#step-6-publish-your-tile", 
            "text": "Complete the documentation  Work with Pivotal to publish your tile", 
            "title": "Step 6. Publish your tile"
        }, 
        {
            "location": "/getting-started/#step-7-maintain-your-tile", 
            "text": "Set up a Concourse Server  Set up a Concourse Pipeline   Create a target PCF pool    Upgrading tiles", 
            "title": "Step 7. Maintain your tile"
        }, 
        {
            "location": "/cf-concepts/", 
            "text": "Cloud Foundry Concepts\n\n\nThere are \nmany ways\n to integrate products with Cloud Foundry.\nThe right one for each product depends on what the product does, and how\ncustomer applications consume it. To determine the best way to integrate your\nproduct, you'll need a good understanding of Cloud Foundry concepts\nlike applications, containers, services, brokers, and buildpacks.\n\n\nThis page provides a collection of links to documentation for the most relevant\nconcepts. If you prefer to learn through guided training,\n\nask us\n about available training options.\n\n\nGeneral Overview\n\n\n\n\nCloud Foundry Subsystems\n\n\nCloud Foundry Command Line Interface\n\n\nDeploying Applications\n\n\nPivotal Ops Manager\n\n\nPivotal Apps Manager", 
            "title": "Cloud Foundry Concepts"
        }, 
        {
            "location": "/cf-concepts/#cloud-foundry-concepts", 
            "text": "There are  many ways  to integrate products with Cloud Foundry.\nThe right one for each product depends on what the product does, and how\ncustomer applications consume it. To determine the best way to integrate your\nproduct, you'll need a good understanding of Cloud Foundry concepts\nlike applications, containers, services, brokers, and buildpacks.  This page provides a collection of links to documentation for the most relevant\nconcepts. If you prefer to learn through guided training, ask us  about available training options.", 
            "title": "Cloud Foundry Concepts"
        }, 
        {
            "location": "/cf-concepts/#general-overview", 
            "text": "Cloud Foundry Subsystems  Cloud Foundry Command Line Interface  Deploying Applications  Pivotal Ops Manager  Pivotal Apps Manager", 
            "title": "General Overview"
        }, 
        {
            "location": "/stages/", 
            "text": "Stages of Integration\n\n\nWhen integrating third-party software with Cloud Foundry, the integration\ntypically progresses through the same set of stages. We recommend this\nstaged approach because it enables early feedback on the value and the\ndesign of the integration, which helps make better decisions about future\nstages.\n\n\nFor service type integrations, the typical stages of integration are:\n\n\n\n\nUser-Provided Service\n\n\nBrokered Service\n\n\nManaged Service\n\n\nDynamic Service\n\n\n\n\nEach of these is described in more detail below. In general, user-experience\nand production-readiness improves as the integration\nprogresses through the stages. But none of the later stages is required.\nIntegration can stop and be declared complete (enough) after any of these.\n\n\nFor non-service integrations (such as applications or buildpacks), a similar\nstaged integration approach is often possible and desirable.\n\n\n \n\n\nStage 1. User-Provided Service\n\n\nEither your software is available as a SaaS-offering, or you already have a\nway to install software on-premise at a customer site. Or also likely, your\ncustomer already has your software, is now adopting PCF, and wants to be\nable to consume your software from applications deployed on PCF.\n\n\nIn most cases, customers can immediately start consuming your software from\ntheir PCF applications through the user-provided service mechanism available\nin Cloud Foundry. Tell them to create a user-provided service in their\napplication org and space using the command:\n\n\ncf create-user-provided-service \nmy-service-name\n -p \ncredentials\n'\n\n\n\n\nor \ncf cups\n for short. The \ncredentials\n argument should be a valid JSON\nstring that contains the URL and credentials necessary to connect to your\nexternally-deployed service.\n\n\nBy doing this, application developers can bind\nto your service and write all code necessary to access it through a Cloud\nFoundry service binding. It is a great way to determine what information\nneeds to be passed in the credential structure (useful in later integration\nstages), verify that the integration works, and develop a test application\nthat can continue to be used for later stages. And from the application\ndeveloper perspective, once this works, later stages will not require any\nfurther code changes. User-provided service bindings are fully compatible with\nbrokered service bindings.\n\n\nStage 2. Brokered Service\n\n\nStage 3. Managed Service\n\n\nStage 3b. High Availability\n\n\nStage 4. Dynamic Service\n\n\nStage 4b. High Availability", 
            "title": "Stages of Integration"
        }, 
        {
            "location": "/stages/#stages-of-integration", 
            "text": "When integrating third-party software with Cloud Foundry, the integration\ntypically progresses through the same set of stages. We recommend this\nstaged approach because it enables early feedback on the value and the\ndesign of the integration, which helps make better decisions about future\nstages.  For service type integrations, the typical stages of integration are:   User-Provided Service  Brokered Service  Managed Service  Dynamic Service   Each of these is described in more detail below. In general, user-experience\nand production-readiness improves as the integration\nprogresses through the stages. But none of the later stages is required.\nIntegration can stop and be declared complete (enough) after any of these.  For non-service integrations (such as applications or buildpacks), a similar\nstaged integration approach is often possible and desirable.", 
            "title": "Stages of Integration"
        }, 
        {
            "location": "/stages/#stage-1-user-provided-service", 
            "text": "Either your software is available as a SaaS-offering, or you already have a\nway to install software on-premise at a customer site. Or also likely, your\ncustomer already has your software, is now adopting PCF, and wants to be\nable to consume your software from applications deployed on PCF.  In most cases, customers can immediately start consuming your software from\ntheir PCF applications through the user-provided service mechanism available\nin Cloud Foundry. Tell them to create a user-provided service in their\napplication org and space using the command:  cf create-user-provided-service  my-service-name  -p  credentials '  or  cf cups  for short. The  credentials  argument should be a valid JSON\nstring that contains the URL and credentials necessary to connect to your\nexternally-deployed service.  By doing this, application developers can bind\nto your service and write all code necessary to access it through a Cloud\nFoundry service binding. It is a great way to determine what information\nneeds to be passed in the credential structure (useful in later integration\nstages), verify that the integration works, and develop a test application\nthat can continue to be used for later stages. And from the application\ndeveloper perspective, once this works, later stages will not require any\nfurther code changes. User-provided service bindings are fully compatible with\nbrokered service bindings.", 
            "title": "Stage 1. User-Provided Service"
        }, 
        {
            "location": "/stages/#stage-2-brokered-service", 
            "text": "", 
            "title": "Stage 2. Brokered Service"
        }, 
        {
            "location": "/stages/#stage-3-managed-service", 
            "text": "", 
            "title": "Stage 3. Managed Service"
        }, 
        {
            "location": "/stages/#stage-3b-high-availability", 
            "text": "", 
            "title": "Stage 3b. High Availability"
        }, 
        {
            "location": "/stages/#stage-4-dynamic-service", 
            "text": "", 
            "title": "Stage 4. Dynamic Service"
        }, 
        {
            "location": "/stages/#stage-4b-high-availability", 
            "text": "", 
            "title": "Stage 4b. High Availability"
        }, 
        {
            "location": "/tile-generator/", 
            "text": "Tile Generator\n\n\nThe Tile Generator is a tool to help you develop, package, test,\nand deploy services and other add-ons to Pivotal Cloud Foundry. Tiles are the\ninstallation package format used by Pivotal's Ops Manager to deploy these\ncomponents to both public and private cloud deployments. The tile generator\nuses templates and patterns that are based on years of experience integrating\nthird-party services into Cloud Foundry, and eliminates much of the need for\nyou to have intimate knowledge of all the tools involved.\n\n\n\n\nTile generator takes your software components, and a simple configuration file\nthat provides the minimal amount of information to describe and customize your\ntile. It then creates everything that's required to deploy your software into\nPivotal Cloud Foundry:\n\n\n\n\nBOSH errands\n to deploy and delete your software, including blue/green\n  deployments for zero-downtime upgrades\n\n\nA \nBOSH release\n suitable for deploying your software to the Elastic Runtime\n  or open-source Cloud Foundry\n\n\nA \nPivotal Ops Manager Tile\n that can be imported into Ops Manager, installed,\n  configured, and deployed, including UI forms and automatic upgrades from\n  previous versions\n\n\nA \nConcourse pipeline configuration\n to enable Continuous Integration of\n  your software with the latest versions of Pivotal Cloud Foundry\n\n\n\n\nUse the tile generator in combination with the \npcf utility\n\nto enable rapid deploy and test cycles of your software.\n\n\nThe current release of the tile generator supports tiles that have any\ncombination of the following package types:\n\n\n\n\nCloud Foundry Applications\n\n\nCloud Foundry Buildpacks\n\n\nCloud Foundry Service Brokers (both inside and outside the Elastic Runtime)\n\n\nDocker images (both inside and outside the Elastic Runtime)\n\n\n\n\nScreencast\n\n\nFor a 7-minute introduction into what tile generator is and does, see\n\nthis screencast\n.\n\n\nHow to Use\n\n\n\n\n\n\nCheck out the tile-generator repo:\n\n\nbash\ngit clone https://github.com/cf-platform-eng/tile-generator.git\n\n\n\n\n\n\nChange to the root directory of the tile generator, and pull down the generator's dependencies:\n\n\nbash\ncd tile-generator\npip install -r requirements.txt\n\n\n\n\n\n\nAdd the \nbin\n directory of tile-generator to your path:\n\n\nbash\nexport PATH=`pwd`/bin:$PATH\n\n\nIf you expect to frequently use the tile generator, you may want to add this to your shell's startup script, i.e. \n.profile\n\n\n\n\n\n\nInstall the \nBOSH CLI\n\n\n\n\n\n\nThen, from within the root directory of the project for which you wish to create a tile, initialize it as a tile repo (we recommend that this be a git repo, but this is not required):\n\n\nbash\ncd \nyour project dir\n\ntile init\n\n\n\n\n\n\nEdit the generated \ntile.yml\n file to define your tile (more details below)\n\n\n\n\n\n\nBuild your tile\n\n\nbash\ntile build\n\n\n\n\n\n\nThe generator will first create a BOSH release (in the \nrelease\n subdirectory),\nthen wrap that release into a Pivotal tile (in the \nproduct\n subdirectory).\nIf required for the installation, it will automatically pull down the latest\nrelease version of the Cloud Foundry CLI.\n\n\nBuilding the Sample\n\n\nThe repository includes a sample tile that exercises most of the features of the\ntile generator (it is used by the CI pipeline to verify that things work correctly).\nYou can build this sample using the following steps:\n\n\ncd sample\nsrc/build.sh\ntile build\n\n\n\n\n\n\nNote:\n\n\nThe sample tile includes a Python application that is re-used in several packages,\nsometimes as an app, sometimes as a service broker. One of the deployments (app3)\nuses the sample application inside a docker image that is currently only modified\nby the CI pipeline. If you modify the sample app, you will have to build your own\ndocker image using the provided \nDockerfile\n and change the image name in\n\nsample/tile.yml\n to include the modified code in app3.\n\n\n\n\nDefining your Tile\n\n\nAll required configuration for your tile is in the file called \ntile.yml\n.\n\ntile init\n will create an initial version for you that can serve as a template.\nThe first section in the file describes the general properties of your tile:\n\n\nname: tile-name # By convention lowercase with dashes\nicon_file: resources/icon.png\nlabel: Brief Text for the Tile Icon\ndescription: Longer description of the tile's purpose\n\n\n\n\nThe \nicon_file\n should be a 128x128 pixel image that will appear on your tile in\nthe Ops Manager GUI. By convention, any resources used by the tile should be\nplaced in the \nresources\n sub-directory of your repo, although this is not\nmandatory. The \nlabel\n text will appear on the tile under your icon.\n\n\nPackages\n\n\nNext you can specify the packages to be included in your tile. The format of\neach package entry depends on the type of package you are adding.\n\n\nPushed Applications\n\n\nApplications (including service brokers) that are being \ncf push\ned into the\nElastic Runtime use the following format:\n\n\n\n- name: my-application\n  type: app \nor\n app-broker\n  manifest:\n    \n# any options that you would normally specify in a cf manifest.yml, including\n\n    buildpack:\n    command:\n    domain:\n    host:\n    instances:\n    memory:\n    path:\n    env:\n    services:\n  health_check: none                 \n# optional\n\n  configurable_persistence: true     \n# optional\n\n  needs_cf_credentials: true         \n# optional\n\n  auto_services: p-mysql p-redis     \n# optional\n\n\n\n\n\nNote: for applications that are normally pushed as multiple files (node.js for example)\nyou should zip up the project files plus all dependencies into a single zip file, then\nedit tile.yml to point to the zipped file:\n\n\ncd \nyour project dir\n\nzip -r resources/\nyour project name\n.zip \nlist of file and dirs to include in the zip\n\n\n\n\n\nIf your application is a service broker, use \napp-broker\n as the type instead of just\n\napp\n. The application will then automatically be registered as a broker on install,\nand deleted on uninstall.\n\n\nhealth_check\n lets you configure the value of the cf cli \n--health_check_type\n\noption. Expect this option to move into the manifest as soon as CF supports it there.\nCurrently, the only valid options are \nnone\n and \nport\n.\n\n\nconfigurable_persistence: true\n results in the user being able to select a backing\nservice for data persistence. If there is a specific broker you want to use, you can\nuse the \nauto-services\n feature described below. If you want to bind to an already\nexisting service instance, use the \nservices\n proeprty of the \nmanifest\n instead.\n\n\nneeds_cf_credentials\n causes the application to receive two additional environment\nvariables named \nCF_ADMIN_USER\n and \nCF_ADMIN_PASSWORD\n with the admin credentials\nfor the Elastic Runtime into which they are being deployed. This allows apps and\nservices to interact with the Cloud Controller.\n\n\nauto_services\n is described in more detail below.\n\n\nService Brokers\n\n\nMost modern service brokers are pushed into the Elastic Runtime as normal\nCF applications. For these types of brokers, use the Pushed Application format\nspecified above, but set the type to \napp-broker\n or \ndocker-app-broker\n instead\nof just \napp\n or \ndocker-app\n.\n\n\nSome service brokers support operator-defined service plans, for instance when\nthe plans reflect customer license keys. To allow operators to add plans from\nthe tile configuration, add the following section:\n\n\n\ndynamic_service_plans:\n- name: description\n  type: string\n  description: \"Some Description\"\n  configurable: true\n- name: key1\n  type: integer\n  description: \"Key 1 of type integer\"\n  configurable: true\n- name: key2\n  type: secret\n  description: \"Key 2 of type Password\"\n  configurable: true\n\n\n\n\nName and GUID fields will be supplied by default for each plan, but all other fields\nare optional and customizable.\n\n\nFor an external service broker, use:\n\n\n\n- name: my-application\n  type: external-broker\n  uri: http://broker3.example.com\n  username: user\n  password: \nsecret\n\n  internal_service_names: 'service1,service2'\n\n\n\n\nBuildpacks\n\n\n\n- name: my-buildpack\n  type: buildpack\n  files:\n  - path: resources/buildpack.zip\n\n\n\n\nDocker Images\n\n\nApplications packages as docker images can be deployed inside or outside the Elastic\nRuntime. To push a docker image as a CF application, use the \nPushed Application\n\nformat specified above, but use the \ndocker-app\n or \ndocker-app-broker\n type instead\nof just \napp\n or \napp-broker\n. The docker image to be used is then specified using\nthe \nimage\n property:\n\n\n\n- name: app1\n  type: docker-app\n  image: test/dockerimage\n  manifest:\n    ...\n\n\n\n\nIf this app is also a service broker, use \ndocker-app-broker\n instead of just\n\ndocker-app\n. This option is appropriate for docker-wrapped 12-factor apps that\ndelegate their persistence to bound services.\n\n\nDocker applications that require persistent storage can not be deployed into\nthe Elastic Runtime. These can be deployed to separate BOSH-managed VMs instead\nby using the \ndocker-bosh\n type:\n\n\n\n- name: docker-bosh1\n  type: docker-bosh\n  cpu: 5\n  memory: 4096\n  ephemeral_disk: 4096\n  persistent_disk: 2048\n  instances: 1\n  manifest: |\n    containers:\n    - name: redis\n      image: \"redis\"\n      command: \"--dir /var/lib/redis/ --appendonly yes\"\n      bind_ports:\n      - \"6379:6379\"\n      bind_volumes:\n      - \"/var/lib/redis\"\n      entrypoint: \"redis-server\"\n      memory: \"256m\"\n      env_vars:\n      - \"EXAMPLE_VAR=1\"\n    - name: mysql\n      image: \"google/mysql\"\n      bind_ports:\n      - \"3306:3306\"\n      bind_volumes:\n      - \"/mysql\"\n    - name: elasticsearch\n      image: \"bosh/elasticsearch\"\n      links:\n      - mysql:db\n      depends_on:\n      - mysql\n      bind_ports:\n      - \"9200:9200\"\n\n\n\n\nIf a docker image cannot be downloaded by BOSH dynamically, its better to provide a ready made docker image and package it as part of the BOSH release. In that case, specify the image as a local file.\n\n\n- name: docker-bosh2\n  type: docker-bosh\n  files:\n  - path: resources/cfplatformeng-docker-tile-example.tgz\n  cpu: 5\n  memory: 4096\n  ephemeral_disk: 4096\n  persistent_disk: 2048\n  instances: 1\n  manifest: |\n    containers:\n    - name: test_docker_image\n      image: \"cfplatformeng/docker-tile-example\"\n      env_vars:\n      - \"EXAMPLE_VAR=1\"\n      # See below on custom forms/variables and binding it to the docker env variable\n      - \"custom_variable_name=((.properties.customer_name.value))\"\n\n\n\nAlso, refer to \ndocker-bosh\n for more details.\n\n\nCustom Forms and Properties\n\n\nYou can pass custom properties to all applications deployed by your tile by adding\nthe to the properties section of \ntile.yml\n:\n\n\nproperties:\n- name: author\n  type: string\n  label: Author\n  value: Tile Ninja\n\n\n\n\nIf you want the properties to be configurable by the tile installer, place them on\na custom for instead:\n\n\nforms:\n- name: custom-form1\n  label: Test Tile\n  description: Custom Properties for Test Tile\n  properties:\n  - name: customer_name\n    type: string\n    label: Full Name\n  - name: street_address\n    type: string\n    label: Street Address\n    description: Address to use for junk mail\n  - name: city\n    type: string\n    label: City\n  - name: zip_code\n    type: string\n    label: ZIP+4\n    default: '90310'\n  - name: country\n    type: dropdown_select\n    label: Country\n    options:\n    - name: country_us\n      label: US\n      default: true\n    - name: country_elsewhere\n      label: Elsewhere\n\n\n\n\nProperties defined in either section will be passed to all pushed applications\nas environment variables (the name of the environment variable will be the same\nas the property name but in ALL_CAPS). They can also be referenced in other parts\nof the configuration file by using \n(( .properties.\nproperty-name\n ))\n instead\nof a hardcoded value.\n\n\nAutomatic Provisioning of Services\n\n\nTile generator automates the provisioning of services. Any application (including\nservice brokers and docker-based applications) that are being pushed into the\nElastic Runtime can automatically be bound to services through the \nauto_services\n\nfeature:\n\n\n\n- name: app1\n  type: app\n  auto_services:\n  - name: p-mysql\n    plan: 100mb-dev\n  - name: p-redis\n\n\n\n\nYou can specify any number of service names, optionally specifying a specific\nplan. During deployment, the generated tile will create an instance of each\nservice if one does not already exist, and then bind that instance to your\npackage.\n\n\nService instances provisioned this way survive updates, but will be deleted\nwhen the tile is uninstalled.\n\n\nNOTE\n that the name is the name of the provided \nservice\n, \nnot\n the \nbroker\n.\nIn many cases these are not the same, and a single broker may even offer\nmultiple services. Use \ncf marketplace\n to see the services and plans\navailable from installed brokers.\n\n\nIf you do not specify a plan, the tile generator will use the first plan\nlisted for the service in the broker catalog. It is a good idea to always\nspecify a service plan. If you \nchange\n the plan between versions of your\ntile, the tile generator will attempt to update the plan while preserving\nthe service (thus not causing data loss during upgrade). If the service\ndoes not support plan changes, this will cause the upgrade to fail.\n\n\nconfigurable_persistence\n is really just a special case of \nauto_services\n,\nletting the user choose between some standard brokers.\n\n\nDeclaring Product Dependencies\n\n\nWhen your product has dependencies on others, you can have Ops Manager\nenforce that dependency by declaring it in your \ntile.yml\n file as follows:\n\n\nrequires_product_versions:\n- name: p-mysql\n  version '~\n 1.7'\n\n\n\n\nIf the required product is not present in the PCF installation, Ops Manager\nwill display a message saying\n\nyour-tile\n requires 'p-mysql' version '~\n 1.7' as a dependency\n, and will\nrefuse to install your tile until that dependency is satisfied.\n\n\nWhen using automatic provisioning of services as described above, it is\noften appropriate to add those products as a dependency. Tile generator can\nnot do this automatically as it can't always determine which product provides\nthe requested service.\n\n\nOrgs and Spaces\n\n\nBy default, the tile generator will create a single new org and space for any\npackages that install into the Elastic Runtime, using the name of the tile and\nappending \n-org\n and \n-space\n, respectively. The default memory quota for a\nnewly created or will be 1024 (1G). You can change any of these defaults by\nspecifying the following properties in \ntile.yml\n:\n\n\n\norg: test-org\norg_quota: 4096\nspace: test-space\n\n\n\n\nSecurity\n\n\nIf your cf packages need outbound access (including access to other packages\nwithin the same tile), you will need to apply an appropriate security group.\nThe following option will remove all constraints on outbound traffic:\n\n\n\napply_open_security_group: true\n\n\n\n\nStemcells\n\n\nThe tile generator will default to a recent stemcell supported by Ops Manager.\nIn most cases the default will be fine, as the stemcell is only used to execute\nCF command lines and/or the docker daemon. But if you have specific stemcell\nrequirements, you can override the defaults in your \ntile.yml\n file by including\na \nstemcell-criteria\n section and replacing the appopriate values:\n\n\n\nstemcell_criteria:\n  os: 'ubunty-trusty'\n  version: '3146.5'     \nNOTE: You must quote the version to force the type to be string\n\n\n\n\n\nVersioning\n\n\nThe tile generator uses semver versioning. By default, \ntile build\n will\ngenerate the next patch release. Major and minor releases can be generated\nby explicitly specifying \ntile build major\n or \ntile build minor\n. Or to\noverride the version number completely, specify a valid semver version on\nthe build command, e.g. \ntile build 3.4.5\n.\n\n\nNo-op content migration rules are generated for every prior release to the\ncurrent release, so that Ops Manager will allow tile upgrades from any\nversion to any newer version. This depends on the existence of the file\n\ntile-history.yml\n. In a pinch, if you need to be able to upgrade from a\nrandom old version to a new one, you can edit that file, or do:\n\n\ntile build \nold-version\n\ntile build \nnew-version\n\n\n\n\n\nThe new tile will then support upgrades from \nold-version\n.\n\n\nExample\n\n\n$ tile build\nname: tibco-bwce\nicon: icon.png\nlabel: TIBCO BusinessWorks Container Edition\ndescription: BusinessWorks edition that supports deploying to Cloud Foundry\nversion: 0.0.2\n\nbosh init release\nbosh generate package cf_cli\nbosh generate package bwce_buildpack\nbosh generate job install_bwce_buildpack\nbosh generate job remove_bwce_buildpack\nbosh create release --final --with-tarball --version 0.0.2\n\ntile generate release\ntile generate metadata\ntile generate errand install_bwce_buildpack\ntile generate errand remove_bwce_buildpack\ntile generate content-migrations\n\ncreated tile tibco-bwce-0.0.2.pivotal\n\n\n\n\nThis tile includes a single large buildpack, and takes less than 15 seconds\nto build including the CF CLI download and the BOSH release generation.\n\n\nSupported Commands\n\n\ninit [\ntile-name\n]\nbuild [patch|minor|major|\nversion\n]\n\n\n\n\nCredits\n\n\n\n\nsparameswaran\n supplied most of the actual template content, originally built as part of \ncf-platform-eng/bosh-generic-sb-release\n\n\nfrodenas\n contributed most of the docker content through \ncloudfoundry-community/docker-boshrelease\n\n\njoshuamckenty\n suggested the jinja template approach he employed in \nopencontrol", 
            "title": "Tile Generator"
        }, 
        {
            "location": "/tile-generator/#tile-generator", 
            "text": "The Tile Generator is a tool to help you develop, package, test,\nand deploy services and other add-ons to Pivotal Cloud Foundry. Tiles are the\ninstallation package format used by Pivotal's Ops Manager to deploy these\ncomponents to both public and private cloud deployments. The tile generator\nuses templates and patterns that are based on years of experience integrating\nthird-party services into Cloud Foundry, and eliminates much of the need for\nyou to have intimate knowledge of all the tools involved.   Tile generator takes your software components, and a simple configuration file\nthat provides the minimal amount of information to describe and customize your\ntile. It then creates everything that's required to deploy your software into\nPivotal Cloud Foundry:   BOSH errands  to deploy and delete your software, including blue/green\n  deployments for zero-downtime upgrades  A  BOSH release  suitable for deploying your software to the Elastic Runtime\n  or open-source Cloud Foundry  A  Pivotal Ops Manager Tile  that can be imported into Ops Manager, installed,\n  configured, and deployed, including UI forms and automatic upgrades from\n  previous versions  A  Concourse pipeline configuration  to enable Continuous Integration of\n  your software with the latest versions of Pivotal Cloud Foundry   Use the tile generator in combination with the  pcf utility \nto enable rapid deploy and test cycles of your software.  The current release of the tile generator supports tiles that have any\ncombination of the following package types:   Cloud Foundry Applications  Cloud Foundry Buildpacks  Cloud Foundry Service Brokers (both inside and outside the Elastic Runtime)  Docker images (both inside and outside the Elastic Runtime)", 
            "title": "Tile Generator"
        }, 
        {
            "location": "/tile-generator/#screencast", 
            "text": "For a 7-minute introduction into what tile generator is and does, see this screencast .", 
            "title": "Screencast"
        }, 
        {
            "location": "/tile-generator/#how-to-use", 
            "text": "Check out the tile-generator repo:  bash\ngit clone https://github.com/cf-platform-eng/tile-generator.git    Change to the root directory of the tile generator, and pull down the generator's dependencies:  bash\ncd tile-generator\npip install -r requirements.txt    Add the  bin  directory of tile-generator to your path:  bash\nexport PATH=`pwd`/bin:$PATH  If you expect to frequently use the tile generator, you may want to add this to your shell's startup script, i.e.  .profile    Install the  BOSH CLI    Then, from within the root directory of the project for which you wish to create a tile, initialize it as a tile repo (we recommend that this be a git repo, but this is not required):  bash\ncd  your project dir \ntile init    Edit the generated  tile.yml  file to define your tile (more details below)    Build your tile  bash\ntile build    The generator will first create a BOSH release (in the  release  subdirectory),\nthen wrap that release into a Pivotal tile (in the  product  subdirectory).\nIf required for the installation, it will automatically pull down the latest\nrelease version of the Cloud Foundry CLI.", 
            "title": "How to Use"
        }, 
        {
            "location": "/tile-generator/#building-the-sample", 
            "text": "The repository includes a sample tile that exercises most of the features of the\ntile generator (it is used by the CI pipeline to verify that things work correctly).\nYou can build this sample using the following steps:  cd sample\nsrc/build.sh\ntile build   Note:  The sample tile includes a Python application that is re-used in several packages,\nsometimes as an app, sometimes as a service broker. One of the deployments (app3)\nuses the sample application inside a docker image that is currently only modified\nby the CI pipeline. If you modify the sample app, you will have to build your own\ndocker image using the provided  Dockerfile  and change the image name in sample/tile.yml  to include the modified code in app3.", 
            "title": "Building the Sample"
        }, 
        {
            "location": "/tile-generator/#defining-your-tile", 
            "text": "All required configuration for your tile is in the file called  tile.yml . tile init  will create an initial version for you that can serve as a template.\nThe first section in the file describes the general properties of your tile:  name: tile-name # By convention lowercase with dashes\nicon_file: resources/icon.png\nlabel: Brief Text for the Tile Icon\ndescription: Longer description of the tile's purpose  The  icon_file  should be a 128x128 pixel image that will appear on your tile in\nthe Ops Manager GUI. By convention, any resources used by the tile should be\nplaced in the  resources  sub-directory of your repo, although this is not\nmandatory. The  label  text will appear on the tile under your icon.", 
            "title": "Defining your Tile"
        }, 
        {
            "location": "/tile-generator/#packages", 
            "text": "Next you can specify the packages to be included in your tile. The format of\neach package entry depends on the type of package you are adding.", 
            "title": "Packages"
        }, 
        {
            "location": "/tile-generator/#pushed-applications", 
            "text": "Applications (including service brokers) that are being  cf push ed into the\nElastic Runtime use the following format:  \n- name: my-application\n  type: app  or  app-broker\n  manifest:\n     # any options that you would normally specify in a cf manifest.yml, including \n    buildpack:\n    command:\n    domain:\n    host:\n    instances:\n    memory:\n    path:\n    env:\n    services:\n  health_check: none                  # optional \n  configurable_persistence: true      # optional \n  needs_cf_credentials: true          # optional \n  auto_services: p-mysql p-redis      # optional   Note: for applications that are normally pushed as multiple files (node.js for example)\nyou should zip up the project files plus all dependencies into a single zip file, then\nedit tile.yml to point to the zipped file:  cd  your project dir \nzip -r resources/ your project name .zip  list of file and dirs to include in the zip   If your application is a service broker, use  app-broker  as the type instead of just app . The application will then automatically be registered as a broker on install,\nand deleted on uninstall.  health_check  lets you configure the value of the cf cli  --health_check_type \noption. Expect this option to move into the manifest as soon as CF supports it there.\nCurrently, the only valid options are  none  and  port .  configurable_persistence: true  results in the user being able to select a backing\nservice for data persistence. If there is a specific broker you want to use, you can\nuse the  auto-services  feature described below. If you want to bind to an already\nexisting service instance, use the  services  proeprty of the  manifest  instead.  needs_cf_credentials  causes the application to receive two additional environment\nvariables named  CF_ADMIN_USER  and  CF_ADMIN_PASSWORD  with the admin credentials\nfor the Elastic Runtime into which they are being deployed. This allows apps and\nservices to interact with the Cloud Controller.  auto_services  is described in more detail below.", 
            "title": "Pushed Applications"
        }, 
        {
            "location": "/tile-generator/#service-brokers", 
            "text": "Most modern service brokers are pushed into the Elastic Runtime as normal\nCF applications. For these types of brokers, use the Pushed Application format\nspecified above, but set the type to  app-broker  or  docker-app-broker  instead\nof just  app  or  docker-app .  Some service brokers support operator-defined service plans, for instance when\nthe plans reflect customer license keys. To allow operators to add plans from\nthe tile configuration, add the following section:  \ndynamic_service_plans:\n- name: description\n  type: string\n  description: \"Some Description\"\n  configurable: true\n- name: key1\n  type: integer\n  description: \"Key 1 of type integer\"\n  configurable: true\n- name: key2\n  type: secret\n  description: \"Key 2 of type Password\"\n  configurable: true  Name and GUID fields will be supplied by default for each plan, but all other fields\nare optional and customizable.  For an external service broker, use:  \n- name: my-application\n  type: external-broker\n  uri: http://broker3.example.com\n  username: user\n  password:  secret \n  internal_service_names: 'service1,service2'", 
            "title": "Service Brokers"
        }, 
        {
            "location": "/tile-generator/#buildpacks", 
            "text": "- name: my-buildpack\n  type: buildpack\n  files:\n  - path: resources/buildpack.zip", 
            "title": "Buildpacks"
        }, 
        {
            "location": "/tile-generator/#docker-images", 
            "text": "Applications packages as docker images can be deployed inside or outside the Elastic\nRuntime. To push a docker image as a CF application, use the  Pushed Application \nformat specified above, but use the  docker-app  or  docker-app-broker  type instead\nof just  app  or  app-broker . The docker image to be used is then specified using\nthe  image  property:  \n- name: app1\n  type: docker-app\n  image: test/dockerimage\n  manifest:\n    ...  If this app is also a service broker, use  docker-app-broker  instead of just docker-app . This option is appropriate for docker-wrapped 12-factor apps that\ndelegate their persistence to bound services.  Docker applications that require persistent storage can not be deployed into\nthe Elastic Runtime. These can be deployed to separate BOSH-managed VMs instead\nby using the  docker-bosh  type:  \n- name: docker-bosh1\n  type: docker-bosh\n  cpu: 5\n  memory: 4096\n  ephemeral_disk: 4096\n  persistent_disk: 2048\n  instances: 1\n  manifest: |\n    containers:\n    - name: redis\n      image: \"redis\"\n      command: \"--dir /var/lib/redis/ --appendonly yes\"\n      bind_ports:\n      - \"6379:6379\"\n      bind_volumes:\n      - \"/var/lib/redis\"\n      entrypoint: \"redis-server\"\n      memory: \"256m\"\n      env_vars:\n      - \"EXAMPLE_VAR=1\"\n    - name: mysql\n      image: \"google/mysql\"\n      bind_ports:\n      - \"3306:3306\"\n      bind_volumes:\n      - \"/mysql\"\n    - name: elasticsearch\n      image: \"bosh/elasticsearch\"\n      links:\n      - mysql:db\n      depends_on:\n      - mysql\n      bind_ports:\n      - \"9200:9200\"  If a docker image cannot be downloaded by BOSH dynamically, its better to provide a ready made docker image and package it as part of the BOSH release. In that case, specify the image as a local file. \n- name: docker-bosh2\n  type: docker-bosh\n  files:\n  - path: resources/cfplatformeng-docker-tile-example.tgz\n  cpu: 5\n  memory: 4096\n  ephemeral_disk: 4096\n  persistent_disk: 2048\n  instances: 1\n  manifest: |\n    containers:\n    - name: test_docker_image\n      image: \"cfplatformeng/docker-tile-example\"\n      env_vars:\n      - \"EXAMPLE_VAR=1\"\n      # See below on custom forms/variables and binding it to the docker env variable\n      - \"custom_variable_name=((.properties.customer_name.value))\"  Also, refer to  docker-bosh  for more details.", 
            "title": "Docker Images"
        }, 
        {
            "location": "/tile-generator/#custom-forms-and-properties", 
            "text": "You can pass custom properties to all applications deployed by your tile by adding\nthe to the properties section of  tile.yml :  properties:\n- name: author\n  type: string\n  label: Author\n  value: Tile Ninja  If you want the properties to be configurable by the tile installer, place them on\na custom for instead:  forms:\n- name: custom-form1\n  label: Test Tile\n  description: Custom Properties for Test Tile\n  properties:\n  - name: customer_name\n    type: string\n    label: Full Name\n  - name: street_address\n    type: string\n    label: Street Address\n    description: Address to use for junk mail\n  - name: city\n    type: string\n    label: City\n  - name: zip_code\n    type: string\n    label: ZIP+4\n    default: '90310'\n  - name: country\n    type: dropdown_select\n    label: Country\n    options:\n    - name: country_us\n      label: US\n      default: true\n    - name: country_elsewhere\n      label: Elsewhere  Properties defined in either section will be passed to all pushed applications\nas environment variables (the name of the environment variable will be the same\nas the property name but in ALL_CAPS). They can also be referenced in other parts\nof the configuration file by using  (( .properties. property-name  ))  instead\nof a hardcoded value.", 
            "title": "Custom Forms and Properties"
        }, 
        {
            "location": "/tile-generator/#automatic-provisioning-of-services", 
            "text": "Tile generator automates the provisioning of services. Any application (including\nservice brokers and docker-based applications) that are being pushed into the\nElastic Runtime can automatically be bound to services through the  auto_services \nfeature:  \n- name: app1\n  type: app\n  auto_services:\n  - name: p-mysql\n    plan: 100mb-dev\n  - name: p-redis  You can specify any number of service names, optionally specifying a specific\nplan. During deployment, the generated tile will create an instance of each\nservice if one does not already exist, and then bind that instance to your\npackage.  Service instances provisioned this way survive updates, but will be deleted\nwhen the tile is uninstalled.  NOTE  that the name is the name of the provided  service ,  not  the  broker .\nIn many cases these are not the same, and a single broker may even offer\nmultiple services. Use  cf marketplace  to see the services and plans\navailable from installed brokers.  If you do not specify a plan, the tile generator will use the first plan\nlisted for the service in the broker catalog. It is a good idea to always\nspecify a service plan. If you  change  the plan between versions of your\ntile, the tile generator will attempt to update the plan while preserving\nthe service (thus not causing data loss during upgrade). If the service\ndoes not support plan changes, this will cause the upgrade to fail.  configurable_persistence  is really just a special case of  auto_services ,\nletting the user choose between some standard brokers.", 
            "title": "Automatic Provisioning of Services"
        }, 
        {
            "location": "/tile-generator/#declaring-product-dependencies", 
            "text": "When your product has dependencies on others, you can have Ops Manager\nenforce that dependency by declaring it in your  tile.yml  file as follows:  requires_product_versions:\n- name: p-mysql\n  version '~  1.7'  If the required product is not present in the PCF installation, Ops Manager\nwill display a message saying your-tile  requires 'p-mysql' version '~  1.7' as a dependency , and will\nrefuse to install your tile until that dependency is satisfied.  When using automatic provisioning of services as described above, it is\noften appropriate to add those products as a dependency. Tile generator can\nnot do this automatically as it can't always determine which product provides\nthe requested service.", 
            "title": "Declaring Product Dependencies"
        }, 
        {
            "location": "/tile-generator/#orgs-and-spaces", 
            "text": "By default, the tile generator will create a single new org and space for any\npackages that install into the Elastic Runtime, using the name of the tile and\nappending  -org  and  -space , respectively. The default memory quota for a\nnewly created or will be 1024 (1G). You can change any of these defaults by\nspecifying the following properties in  tile.yml :  \norg: test-org\norg_quota: 4096\nspace: test-space", 
            "title": "Orgs and Spaces"
        }, 
        {
            "location": "/tile-generator/#security", 
            "text": "If your cf packages need outbound access (including access to other packages\nwithin the same tile), you will need to apply an appropriate security group.\nThe following option will remove all constraints on outbound traffic:  \napply_open_security_group: true", 
            "title": "Security"
        }, 
        {
            "location": "/tile-generator/#stemcells", 
            "text": "The tile generator will default to a recent stemcell supported by Ops Manager.\nIn most cases the default will be fine, as the stemcell is only used to execute\nCF command lines and/or the docker daemon. But if you have specific stemcell\nrequirements, you can override the defaults in your  tile.yml  file by including\na  stemcell-criteria  section and replacing the appopriate values:  \nstemcell_criteria:\n  os: 'ubunty-trusty'\n  version: '3146.5'      NOTE: You must quote the version to force the type to be string", 
            "title": "Stemcells"
        }, 
        {
            "location": "/tile-generator/#versioning", 
            "text": "The tile generator uses semver versioning. By default,  tile build  will\ngenerate the next patch release. Major and minor releases can be generated\nby explicitly specifying  tile build major  or  tile build minor . Or to\noverride the version number completely, specify a valid semver version on\nthe build command, e.g.  tile build 3.4.5 .  No-op content migration rules are generated for every prior release to the\ncurrent release, so that Ops Manager will allow tile upgrades from any\nversion to any newer version. This depends on the existence of the file tile-history.yml . In a pinch, if you need to be able to upgrade from a\nrandom old version to a new one, you can edit that file, or do:  tile build  old-version \ntile build  new-version   The new tile will then support upgrades from  old-version .", 
            "title": "Versioning"
        }, 
        {
            "location": "/tile-generator/#example", 
            "text": "$ tile build\nname: tibco-bwce\nicon: icon.png\nlabel: TIBCO BusinessWorks Container Edition\ndescription: BusinessWorks edition that supports deploying to Cloud Foundry\nversion: 0.0.2\n\nbosh init release\nbosh generate package cf_cli\nbosh generate package bwce_buildpack\nbosh generate job install_bwce_buildpack\nbosh generate job remove_bwce_buildpack\nbosh create release --final --with-tarball --version 0.0.2\n\ntile generate release\ntile generate metadata\ntile generate errand install_bwce_buildpack\ntile generate errand remove_bwce_buildpack\ntile generate content-migrations\n\ncreated tile tibco-bwce-0.0.2.pivotal  This tile includes a single large buildpack, and takes less than 15 seconds\nto build including the CF CLI download and the BOSH release generation.", 
            "title": "Example"
        }, 
        {
            "location": "/tile-generator/#supported-commands", 
            "text": "init [ tile-name ]\nbuild [patch|minor|major| version ]", 
            "title": "Supported Commands"
        }, 
        {
            "location": "/tile-generator/#credits", 
            "text": "sparameswaran  supplied most of the actual template content, originally built as part of  cf-platform-eng/bosh-generic-sb-release  frodenas  contributed most of the docker content through  cloudfoundry-community/docker-boshrelease  joshuamckenty  suggested the jinja template approach he employed in  opencontrol", 
            "title": "Credits"
        }, 
        {
            "location": "/pcf-command/", 
            "text": "PCF Utility\n\n\nThe \npcf\n utility provides a command line interface to Pivotal Cloud Foundry for\nthe purpose of deploying and testing tiles. Its primary reason for existence is\nto enable Ops Manager access from CI pipelines, but developers also find it\nconvenient to use this CLI rather than the Ops manager GUI.\n\n\nThe \npcf\n utility also allows you to test your tile's BOSH errands\ndirectly from your CLI, without going through Ops Manager and BOSH. This greatly\nreduces the time it takes to deploy/test each iteration of your software components.\n\n\nAuthentication\n\n\nThe \npcf\n utility looks for a file called \nmetadata\n in the current directory.\nThis file is expected to provide the URL and credentials to connect to\nOps Manager, in the following format:\n\n\n---\nopsmgr:\n    url: https://opsmgr.example.com\n    username: admin\n    password: \nredacted\n\n\n\n\n\nThe reason for this file naming is because this is how Concourse passes\ncredentials of a \"claimed\" PCF pool resource to the CI pipeline scripts.\nFor interactive use, this means that you will have to create a \nmetadata\n\nfile in the directory where you run the \npcf\n command.\n\n\nWe recommend that you do\n \nnot\n \ncreate this file inside your git (or other\nversion control system) repository, as you do not want to accidentally commit\nthese credentials to version control.\n\n\nCommands\n\n\nThe \npcf\n utility implements many different commands. To see available commands:\n\n\n$ pcf --help\nUsage: pcf [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  apply-changes\n  cf-info\n  changes\n  configure\n  delete-unused-products\n  import\n  install\n  is-available\n  is-installed\n  logs\n  products\n  settings\n  target\n  test-errand\n  uninstall\n\n\n\n\nChecking Ops Manager Settings\n\n\nTo see which products are currently available and installed in Ops Manager:\n\n\n$ pcf products\n- p-bosh 1.7.0.0 (installed)\n- cf 1.7.0-build.258 (installed)\n- test-tile 0.3.95\n\n\n\n\nTo test if a specific product is available or installed from within a script:\n\n\n$ pcf is-available test-tile \n echo \nProduct test-tile is available\n\n$ pcf is-installed test-tile \n echo \nProduct test-tile is installed\n\n\n\n\n\nYou can retrieve the settings for a specific product (this will give you a \nlot\n of json):\n\n\n$ pcf settings test-tile\n{\n    \nnetwork_reference\n: \n669e213111ab5aa1008a\n,\n    \nguid\n: \ntest-tile-be3e50cf26c530acca6e\n,\n    \njobs\n: [\n        {\n            \ninstance\n: {\n                \nidentifier\n: \ninstances\n\n            },\n            \nidentifier\n: \ncompilation\n,\n            \nguid\n: \ncompilation-066a85d82fbcd936f9d7\n,\n            \ninstallation_name\n: \ncompilation\n,\n            \nvm_credentials\n: {\n                \npassword\n: \nredacted\n,\n                \nsalt\n: \nredacted\n,\n                \nidentity\n: \nvcap\n\n            }\n        },\n        {\n            \nguid\n: \ndeploy-all-b83a7cb7be00ebfd26d6\n,\n            \nvm_credentials\n: {\n    ...\n\n\n\n\nTesting Errands\n\n\nYou can test your tile's BOSH errands directly from your current shell. Deploy\nyour tile's packages using:\n\n\n$ pcf test-errand test-tile-repo deploy-all\n/usr/local/bin/cf version 6.15.0+fa1bfe2-2016-01-13\ncf api https://api.run-04.example.com --skip-ssl-validation\ncf auth system_services \nredacted\n\ncf target -o test-tile-org\ncf update-quota test-tile-org-quota -m 4096m -r 1000 -s 100\ncf update-quota test-tile-org-quota --allow-paid-service-plans\ncf set-quota test-tile-org test-tile-org-quota\ncf target -s test-tile-space\ncf bind-running-security-group all_open\ncf push app1-0.0.2 -n app1 -d cfapps-04.example.com -f sample/release/blobs/app1/manifest.yml --no-start\ncf set-env app1-0.0.2 UAA_HOST https://uaa.run-04.example.com\ncf set-env app1-0.0.2 CC_HOST https://api.run-04.example.com\ncf set-env app1-0.0.2 LOGIN_HOST https://login.run-04.example.com\ncf set-env app1-0.0.2 ROOT $HOME\ncf set-env app1-0.0.2 SCHEME https\ncf set-env app1-0.0.2 VERIFY_SSL True\ncf set-env app1-0.0.2 CF_ORG test-tile-org\ncf set-env app1-0.0.2 CF_SPACE test-tile-space\ncf set-env app1-0.0.2 CF_TARGET https://api.run-04.example.com\ncf set-env app1-0.0.2 SECURITY_USER_NAME admin\n...\n\n\n\n\n\nDelete them using:\n\n\n$ pcf test-errand test-tile-repo delete-all\n/usr/local/bin/cf version 6.15.0+fa1bfe2-2016-01-13\ncf api https://api.run-04.example.com --skip-ssl-validation\ncf auth system_services \nredacted\n\ncf delete -f app3-0.0.2\ncf delete-buildpack -f noop_buildpack\ncf purge-service-offering -f service-broker2-service\ncf delete-service-broker -f service-broker2\ncf delete -f service-broker2-0.0.2\ncf delete -f app2-0.0.2\ncf purge-service-offering -f service-broker1-service\ncf delete-service-broker -f service-broker1\ncf delete -f service-broker1-0.0.2\ncf delete -f app1-0.0.2\ncf delete-space -f test-tile-space\ncf delete-org -f test-tile-org\ncf delete-quota -f test-tile-org-quota\n\n\n\n\n\nThis \nonly\n reliably works for the above two errands generated by the tile\ngenerator. If your tile includes any packages that are not deployed into them\nElastic Runtime, such as docker-bosh packages, those will not be deployed when\nusing this method.\n\n\nDeploying Tiles\n\n\nOnce your software works and correctly deploys using \ntest-errand\n, you can go\nthrough the real Ops Manager deployment process from the CLI, as you would\nnormally do through the Ops Manager GUI.\n\n\nImport your .pivotal file into Ops Manager:\n\n\n$ pcf import sample/product/test-tile-0.0.2.pivotal\n\n\n\n\nInstall the uploaded version of your product:\n\n\n$ pcf install test-tile 0.0.2\n\n\n\n\nWhere you would normally configure the tile settings in the GUI, the \nconfigure\n\ncommand lets you pass in any user-specified properties as a .yml file. This command\nalso sets the stemcell for the tile to the same one used by your Elastic Runtime,\nto avoid the need to upload a tile-specific stemcell.\n\n\n$ pcf configure test-tile sample/missing-properties.yml\n- Using stemcell bosh-vsphere-esxi-ubuntu-trusty-go_agent version 3215\n\n\n\n\nThe property file looks like this:\n\n\n---\ncustomer_name: Jimmy's Johnnys\nstreet_address: Cartaway Alley\ncity: New Jersey\ncountry: US\napp2:\n  persistence_store_type: none\n\n\n\n\nTo see what changes are ready to be applied:\n\n\n$ pcf changes\ninstall: test-tile-207b165fcb7dc8b2597b\ndelete:  \n\n\n\n\nTo apply these changes:\n\n\n$ pcf apply-changes\n  ===== 2016-04-21 18:45:05 UTC Running \nbosh-init deploy /var/tempest/workspaces/default/deployments/bosh.yml\n\n  Deployment manifest: '/var/tempest/workspaces/default/deployments/bosh.yml'\n  Deployment state: '/var/tempest/workspaces/default/deployments/bosh-state.json'\n\n  Started validating\n    Validating release 'bosh'... Finished (00:00:08)\n    Validating release 'bosh-vsphere-cpi'... Finished (00:00:00)\n    Validating release 'uaa'... Finished (00:00:06)\n    Validating cpi release... Finished (00:00:00)\n    Validating deployment manifest... Finished (00:00:00)\n\n\n\n\npcf apply-changes\n automatically tails the logs for the installation process\nit started. If this gets aborted for any reason, you can always tail the logs\nof the most recent installation:\n\n\n$ pcf logs\n\n\n\n\nRemoving Tiles\n\n\nTo uninstall a tile:\n\n\n$ pcf uninstall test-tile\n\n\n\n\nIf you accumulate a lot of uninstalled tiles or old versions, you can clean\nup Ops Manager's available products (and disk space):\n\n\n$ pcf delete-unused-products\n\n\n\n\nAccessing Elastic Runtime\n\n\nTo see details about the Elastic Runtime of your PCF environment:\n\n\n$ pcf cf-info\n- admin_password: \nredacted\n\n- admin_username: admin\n- apps_domain: cfapps-04.example.com\n- system_domain: run-04.example.com\n- system_services_password: \nredacted\n\n- system_services_username: system_services\n\n\n\n\nTo target your \ncf\n command line at this PCF environment:\n\n\n$ pcf target\nSetting api endpoint to api.example.com...\nOK\n\nAPI endpoint:   https://api.example.com (API version: 2.52.0)   \nUser:           admin   \nOrg:            my-org\nSpace:          my-space\nAPI endpoint: https://api.example.com\nAuthenticating...\nOK\n\n...", 
            "title": "PCF Command"
        }, 
        {
            "location": "/pcf-command/#pcf-utility", 
            "text": "The  pcf  utility provides a command line interface to Pivotal Cloud Foundry for\nthe purpose of deploying and testing tiles. Its primary reason for existence is\nto enable Ops Manager access from CI pipelines, but developers also find it\nconvenient to use this CLI rather than the Ops manager GUI.  The  pcf  utility also allows you to test your tile's BOSH errands\ndirectly from your CLI, without going through Ops Manager and BOSH. This greatly\nreduces the time it takes to deploy/test each iteration of your software components.", 
            "title": "PCF Utility"
        }, 
        {
            "location": "/pcf-command/#authentication", 
            "text": "The  pcf  utility looks for a file called  metadata  in the current directory.\nThis file is expected to provide the URL and credentials to connect to\nOps Manager, in the following format:  ---\nopsmgr:\n    url: https://opsmgr.example.com\n    username: admin\n    password:  redacted   The reason for this file naming is because this is how Concourse passes\ncredentials of a \"claimed\" PCF pool resource to the CI pipeline scripts.\nFor interactive use, this means that you will have to create a  metadata \nfile in the directory where you run the  pcf  command.  We recommend that you do   not   create this file inside your git (or other\nversion control system) repository, as you do not want to accidentally commit\nthese credentials to version control.", 
            "title": "Authentication"
        }, 
        {
            "location": "/pcf-command/#commands", 
            "text": "The  pcf  utility implements many different commands. To see available commands:  $ pcf --help\nUsage: pcf [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  apply-changes\n  cf-info\n  changes\n  configure\n  delete-unused-products\n  import\n  install\n  is-available\n  is-installed\n  logs\n  products\n  settings\n  target\n  test-errand\n  uninstall", 
            "title": "Commands"
        }, 
        {
            "location": "/pcf-command/#checking-ops-manager-settings", 
            "text": "To see which products are currently available and installed in Ops Manager:  $ pcf products\n- p-bosh 1.7.0.0 (installed)\n- cf 1.7.0-build.258 (installed)\n- test-tile 0.3.95  To test if a specific product is available or installed from within a script:  $ pcf is-available test-tile   echo  Product test-tile is available \n$ pcf is-installed test-tile   echo  Product test-tile is installed   You can retrieve the settings for a specific product (this will give you a  lot  of json):  $ pcf settings test-tile\n{\n     network_reference :  669e213111ab5aa1008a ,\n     guid :  test-tile-be3e50cf26c530acca6e ,\n     jobs : [\n        {\n             instance : {\n                 identifier :  instances \n            },\n             identifier :  compilation ,\n             guid :  compilation-066a85d82fbcd936f9d7 ,\n             installation_name :  compilation ,\n             vm_credentials : {\n                 password :  redacted ,\n                 salt :  redacted ,\n                 identity :  vcap \n            }\n        },\n        {\n             guid :  deploy-all-b83a7cb7be00ebfd26d6 ,\n             vm_credentials : {\n    ...", 
            "title": "Checking Ops Manager Settings"
        }, 
        {
            "location": "/pcf-command/#testing-errands", 
            "text": "You can test your tile's BOSH errands directly from your current shell. Deploy\nyour tile's packages using:  $ pcf test-errand test-tile-repo deploy-all\n/usr/local/bin/cf version 6.15.0+fa1bfe2-2016-01-13\ncf api https://api.run-04.example.com --skip-ssl-validation\ncf auth system_services  redacted \ncf target -o test-tile-org\ncf update-quota test-tile-org-quota -m 4096m -r 1000 -s 100\ncf update-quota test-tile-org-quota --allow-paid-service-plans\ncf set-quota test-tile-org test-tile-org-quota\ncf target -s test-tile-space\ncf bind-running-security-group all_open\ncf push app1-0.0.2 -n app1 -d cfapps-04.example.com -f sample/release/blobs/app1/manifest.yml --no-start\ncf set-env app1-0.0.2 UAA_HOST https://uaa.run-04.example.com\ncf set-env app1-0.0.2 CC_HOST https://api.run-04.example.com\ncf set-env app1-0.0.2 LOGIN_HOST https://login.run-04.example.com\ncf set-env app1-0.0.2 ROOT $HOME\ncf set-env app1-0.0.2 SCHEME https\ncf set-env app1-0.0.2 VERIFY_SSL True\ncf set-env app1-0.0.2 CF_ORG test-tile-org\ncf set-env app1-0.0.2 CF_SPACE test-tile-space\ncf set-env app1-0.0.2 CF_TARGET https://api.run-04.example.com\ncf set-env app1-0.0.2 SECURITY_USER_NAME admin\n...  Delete them using:  $ pcf test-errand test-tile-repo delete-all\n/usr/local/bin/cf version 6.15.0+fa1bfe2-2016-01-13\ncf api https://api.run-04.example.com --skip-ssl-validation\ncf auth system_services  redacted \ncf delete -f app3-0.0.2\ncf delete-buildpack -f noop_buildpack\ncf purge-service-offering -f service-broker2-service\ncf delete-service-broker -f service-broker2\ncf delete -f service-broker2-0.0.2\ncf delete -f app2-0.0.2\ncf purge-service-offering -f service-broker1-service\ncf delete-service-broker -f service-broker1\ncf delete -f service-broker1-0.0.2\ncf delete -f app1-0.0.2\ncf delete-space -f test-tile-space\ncf delete-org -f test-tile-org\ncf delete-quota -f test-tile-org-quota  This  only  reliably works for the above two errands generated by the tile\ngenerator. If your tile includes any packages that are not deployed into them\nElastic Runtime, such as docker-bosh packages, those will not be deployed when\nusing this method.", 
            "title": "Testing Errands"
        }, 
        {
            "location": "/pcf-command/#deploying-tiles", 
            "text": "Once your software works and correctly deploys using  test-errand , you can go\nthrough the real Ops Manager deployment process from the CLI, as you would\nnormally do through the Ops Manager GUI.  Import your .pivotal file into Ops Manager:  $ pcf import sample/product/test-tile-0.0.2.pivotal  Install the uploaded version of your product:  $ pcf install test-tile 0.0.2  Where you would normally configure the tile settings in the GUI, the  configure \ncommand lets you pass in any user-specified properties as a .yml file. This command\nalso sets the stemcell for the tile to the same one used by your Elastic Runtime,\nto avoid the need to upload a tile-specific stemcell.  $ pcf configure test-tile sample/missing-properties.yml\n- Using stemcell bosh-vsphere-esxi-ubuntu-trusty-go_agent version 3215  The property file looks like this:  ---\ncustomer_name: Jimmy's Johnnys\nstreet_address: Cartaway Alley\ncity: New Jersey\ncountry: US\napp2:\n  persistence_store_type: none  To see what changes are ready to be applied:  $ pcf changes\ninstall: test-tile-207b165fcb7dc8b2597b\ndelete:    To apply these changes:  $ pcf apply-changes\n  ===== 2016-04-21 18:45:05 UTC Running  bosh-init deploy /var/tempest/workspaces/default/deployments/bosh.yml \n  Deployment manifest: '/var/tempest/workspaces/default/deployments/bosh.yml'\n  Deployment state: '/var/tempest/workspaces/default/deployments/bosh-state.json'\n\n  Started validating\n    Validating release 'bosh'... Finished (00:00:08)\n    Validating release 'bosh-vsphere-cpi'... Finished (00:00:00)\n    Validating release 'uaa'... Finished (00:00:06)\n    Validating cpi release... Finished (00:00:00)\n    Validating deployment manifest... Finished (00:00:00)  pcf apply-changes  automatically tails the logs for the installation process\nit started. If this gets aborted for any reason, you can always tail the logs\nof the most recent installation:  $ pcf logs", 
            "title": "Deploying Tiles"
        }, 
        {
            "location": "/pcf-command/#removing-tiles", 
            "text": "To uninstall a tile:  $ pcf uninstall test-tile  If you accumulate a lot of uninstalled tiles or old versions, you can clean\nup Ops Manager's available products (and disk space):  $ pcf delete-unused-products", 
            "title": "Removing Tiles"
        }, 
        {
            "location": "/pcf-command/#accessing-elastic-runtime", 
            "text": "To see details about the Elastic Runtime of your PCF environment:  $ pcf cf-info\n- admin_password:  redacted \n- admin_username: admin\n- apps_domain: cfapps-04.example.com\n- system_domain: run-04.example.com\n- system_services_password:  redacted \n- system_services_username: system_services  To target your  cf  command line at this PCF environment:  $ pcf target\nSetting api endpoint to api.example.com...\nOK\n\nAPI endpoint:   https://api.example.com (API version: 2.52.0)   \nUser:           admin   \nOrg:            my-org\nSpace:          my-space\nAPI endpoint: https://api.example.com\nAuthenticating...\nOK\n\n...", 
            "title": "Accessing Elastic Runtime"
        }, 
        {
            "location": "/contacts/", 
            "text": "Contact Us", 
            "title": "Contacts"
        }, 
        {
            "location": "/contacts/#contact-us", 
            "text": "", 
            "title": "Contact Us"
        }
    ]
}